<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Echoes of the Light</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
    }
    canvas {
      display: block;
      margin: auto;
      background: #222;
    }
    #dialogBox {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 90%;
      max-width: 480px;
      padding: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      font-family: sans-serif;
      font-size: 16px;
      border: 2px solid white;
      display: none;
      z-index: 10;
    }
  </style>
</head>
<body>
<canvas id="game" width="512" height="384"></canvas>
<div id="dialogBox"></div>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const dialogBox = document.getElementById("dialogBox");

const TILE_SIZE = 16;
const SCREEN_WIDTH = canvas.width;
const SCREEN_HEIGHT = canvas.height;
const MAP_WIDTH = 50;
const MAP_HEIGHT = 50;

const map = Array.from({ length: MAP_HEIGHT }, (_, y) =>
  Array.from({ length: MAP_WIDTH }, (_, x) =>
    x === 0 || y === 0 || x === MAP_WIDTH - 1 || y === MAP_HEIGHT - 1 || Math.random() < 0.08 ? 1 : 0
  )
);

const sprites = new Image();
sprites.src = "https://i.imgur.com/qpX8qDM.png";

const player = {
  x: 80,
  y: 80,
  width: 16,
  height: 16,
  speed: 2,
  health: 5,
  maxHealth: 5,
  dir: "down",
  swordCooldown: 0,
  inventory: { key: false, potion: false },
  quests: { swordFound: false }
};

const keys = {};
window.addEventListener("keydown", e => keys[e.key] = true);
window.addEventListener("keyup", e => keys[e.key] = false);

function isSolid(x, y) {
  const tx = Math.floor(x / TILE_SIZE);
  const ty = Math.floor(y / TILE_SIZE);
  return map[ty]?.[tx] === 1;
}

const enemies = [
  { x: 220, y: 220, health: 2, alive: true },
  { x: 280, y: 180, health: 2, alive: true }
];

const npcs = [
  {
    name: "Old Man",
    x: 130,
    y: 80,
    width: 16,
    height: 16,
    dialog: [
      "Hello, brave one!",
      "I lost my sword in the woods...",
      "Please find it for me!"
    ],
    quest: "swordFound",
    completedText: "You found it! Thank you!",
    talked: false
  }
];

const items = [
  {
    type: "sword",
    x: 350,
    y: 100,
    picked: false
  }
];

function rectsIntersect(a, b) {
  return a.x < b.x + b.width &&
         a.x + a.width > b.x &&
         a.y < b.y + b.height &&
         a.y + a.height > b.y;
}

function updatePlayer() {
  let dx = 0, dy = 0;
  if (keys["ArrowUp"] || keys["w"]) dy -= player.speed, player.dir = "up";
  if (keys["ArrowDown"] || keys["s"]) dy += player.speed, player.dir = "down";
  if (keys["ArrowLeft"] || keys["a"]) dx -= player.speed, player.dir = "left";
  if (keys["ArrowRight"] || keys["d"]) dx += player.speed, player.dir = "right";

  const newX = player.x + dx;
  const newY = player.y + dy;
  if (!isSolid(newX, player.y)) player.x = newX;
  if (!isSolid(player.x, newY)) player.y = newY;

  if (player.swordCooldown > 0) player.swordCooldown--;
  if (keys[" "]) swingSword();
}

function getSwordHitbox() {
  const size = 12;
  if (player.dir === "up") return { x: player.x, y: player.y - size, width: 16, height: size };
  if (player.dir === "down") return { x: player.x, y: player.y + player.height, width: 16, height: size };
  if (player.dir === "left") return { x: player.x - size, y: player.y, width: size, height: 16 };
  return { x: player.x + player.width, y: player.y, width: size, height: 16 };
}

function swingSword() {
  if (player.swordCooldown > 0) return;
  player.swordCooldown = 20;
  const hitbox = getSwordHitbox();
  enemies.forEach(e => {
    if (e.alive && rectsIntersect(hitbox, { x: e.x, y: e.y, width: 16, height: 16 })) {
      e.health--;
      if (e.health <= 0) e.alive = false;
    }
  });
}

function updateEnemies() {
  enemies.forEach(e => {
    if (!e.alive) return;
    const dx = player.x - e.x;
    const dy = player.y - e.y;
    const dist = Math.hypot(dx, dy);
    if (dist < 200) {
      const angle = Math.atan2(dy, dx);
      const step = 1;
      const newX = e.x + Math.cos(angle) * step;
      const newY = e.y + Math.sin(angle) * step;
      if (!isSolid(newX, newY)) e.x = newX, e.y = newY;
    }
    if (rectsIntersect(player, { x: e.x, y: e.y, width: 16, height: 16 })) {
      player.health -= 0.01;
    }
  });
}

function updateItems() {
  items.forEach(item => {
    if (item.picked) return;
    if (rectsIntersect(player, { x: item.x, y: item.y, width: 16, height: 16 })) {
      item.picked = true;
      if (item.type === "sword") player.quests.swordFound = true;
    }
  });
}

function updateDialog() {
  if (!keys["e"]) return;
  for (const npc of npcs) {
    if (rectsIntersect(player, npc)) {
      showDialog(npc);
      break;
    }
  }
}

let dialogIndex = 0;
function showDialog(npc) {
  dialogBox.style.display = "block";
  if (npc.quest && player.quests[npc.quest]) {
    dialogBox.textContent = npc.completedText;
  } else {
    dialogBox.textContent = npc.dialog[dialogIndex] || "";
    dialogIndex = (dialogIndex + 1) % npc.dialog.length;
  }
}

function hideDialog() {
  if (!keys["e"]) dialogBox.style.display = "none";
}

function drawMap(camX, camY) {
  for (let y = 0; y < MAP_HEIGHT; y++) {
    for (let x = 0; x < MAP_WIDTH; x++) {
      const tile = map[y][x];
      ctx.drawImage(sprites, tile * 16, 0, 16, 16, x * TILE_SIZE - camX, y * TILE_SIZE - camY, 16, 16);
    }
  }
}

function drawEntities(camX, camY) {
  enemies.forEach(e => {
    if (e.alive) ctx.drawImage(sprites, 16, 16, 16, 16, e.x - camX, e.y - camY, 16, 16);
  });
  npcs.forEach(npc => {
    ctx.drawImage(sprites, 32, 16, 16, 16, npc.x - camX, npc.y - camY, 16, 16);
  });
  items.forEach(item => {
    if (!item.picked) ctx.drawImage(sprites, 48, 0, 16, 16, item.x - camX, item.y - camY, 16, 16);
  });
}

function drawPlayer(camX, camY) {
  ctx.drawImage(sprites, 0, 16, 16, 16, player.x - camX, player.y - camY, 16, 16);
  if (player.swordCooldown > 10) {
    const s = getSwordHitbox();
    ctx.fillStyle = "rgba(255,255,255,0.5)";
    ctx.fillRect(s.x - camX, s.y - camY, s.width, s.height);
  }
}

function drawUI() {
  for (let i = 0; i < player.maxHealth; i++) {
    ctx.drawImage(sprites, i < player.health ? 32 : 48, 16, 16, 16, 8 + i * 20, 8, 16, 16);
  }
  if (player.inventory.key)
    ctx.drawImage(sprites, 64, 16, 16, 16, 450, 10, 16, 16);
  if (player.inventory.potion)
    ctx.drawImage(sprites, 80, 16, 16, 16, 430, 10, 16, 16);
}

function gameLoop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  updatePlayer();
  updateEnemies();
  updateItems();
  updateDialog();
  hideDialog();

  const camX = player.x - SCREEN_WIDTH / 2 + player.width / 2;
  const camY = player.y - SCREEN_HEIGHT / 2 + player.height / 2;

  drawMap(camX, camY);
  drawEntities(camX, camY);
  drawPlayer(camX, camY);
  drawUI();

  requestAnimationFrame(gameLoop);
}

sprites.onload = () => {
  gameLoop();
};
</script>
</body>
</html>
